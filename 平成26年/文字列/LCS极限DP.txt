#include<cstdio>
#include<cstdlib>
#include<cstring>

#define MAXI 0xffff
typedef unsigned short int USHORT;

char stra[30005],strb[30005];
USHORT lena, lenb;
USHORT Li[2][30005]; //Li[k][i]=Li[k]=min{j|LCS(A[1..i],B[1..j]=k)}，不存在为INF
/*
Li矩阵显然有如下的性质：
Li[1]<Li[2]<...<Li[m]
Li+1[k]<=Li[k]
Li[k]<Li+1[k+1]
Li+1[k]=min{j,Li[k]},j=min{j|A[i+1]=B[j]且j>Li[k-1]}
*/

//快速计算Li矩阵的方法，时间复杂度上界O(pm)，p=LCS(A[1..m],B[1..n])
USHORT LCS(char *A, char *B, USHORT m, USHORT n)
{
	int i, j, k, cur, tmp, limit, start = 0;

	cur = 0;
	memset(Li, 0, sizeof(Li));
	//计算L0[1]
	/*
	for(j=0;j<n;j++)
	{
		if(A[0]==B[j])
		{
			Li[cur][1] = j+1;
			break;
		}
	}
	if(j == n)
	{
		Li[cur][1] = MAXI;
		start++;
	}*/
	limit = MAXI;
	for(k=1;k<=m;k++)
	{
		/*if(k == 1)
			i = 1;
		else{
			i = k - 1;
			Li[cur][i] = MAXI;
		}*/
		i = start;  //对于较少INF的场合start优化不如不优化
		Li[cur][i] = MAXI;
		for(;i<m;i++)
		{
			Li[cur][i+1] = Li[cur][i];
			if(i >= limit)
				Li[cur^1][i] = k - 1;
			tmp = (Li[cur][i] > n ? n + 1 : Li[cur][i]);
			for(j=Li[cur^1][i]+1;j<tmp;j++)
			{
				if(A[i] == B[j-1])
				{
					Li[cur][i+1] = j;
					break;
				}
			}
			if(Li[cur][i+1] > n)
				start++;
			else if(Li[cur][i+1] == k)
			{
				//for(j=i+1;j<=m;j++)
				//	Li[cur][j] = k;
				limit = i + 1;  //limit的优化对m较小的场合效果不好
				break;
			}
			
		}
		if(i >= m)
			limit = MAXI;
		if(Li[cur][m] > n)  //这里不需要特判limit
			break;

		cur ^= 1;
	}

	return (k - 1);
}

bool input()
{
	if(scanf("%s%s",stra,strb)==EOF)
		return false;
	lena = strlen(stra);
	lenb = strlen(strb);
	return true;
}

int main()
{
	while(input())
	{
		if(lena >= lenb)
			printf("%d\n",LCS(stra, strb, lena, lenb));
		else
			printf("%d\n",LCS(strb, stra, lenb, lena));
	}
	return 0;
}